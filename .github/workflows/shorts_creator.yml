name: Video Generation and Upload Pipeline
on:
  # Trigger on push to main branch
  push:
    branches: [ main ]
  # Allow manual triggering
  workflow_dispatch:
  # Optional: Schedule runs
  # schedule:
  #   - cron: '0 0 * * 0'  # Run weekly on Sundays at midnight

jobs:
  generate-and-upload:
    runs-on: ubuntu-latest

    # Set UTF-8 locale environment variables
    env:
      PYTHONIOENCODING: "utf-8"
      LC_ALL: "C.UTF-8"
      LANG: "C.UTF-8"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y ffmpeg libsm6 libxext6 libxrender-dev libsndfile1 espeak-ng

      - name: Install Python dependencies
        run: |
          # Upgrade pip first
          python -m pip install --upgrade pip
          # Install and upgrade key packages to their latest versions
          python -m pip install --upgrade jupyter nbconvert ipykernel matplotlib pandas numpy
          python -m pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
          python -m pip install --upgrade pydub pillow requests
          python -m pip install --upgrade papermill opencv-python dropbox google-cloud-texttospeech SpeechRecognition pytube beautifulsoup4 youtube-dl kokoro soundfile google-generativeai yt-dlp
          python -m pip install moviepy==1.0.3
          # Add dropbox SDK for custom upload handling
          python -m pip install dropbox

      - name: Register ipykernel for current environment
        run: python -m ipykernel install --name=github-actions --display-name="Python 3 (github-actions)" --sys-prefix

      - name: Verify moviepy installation
        run: python -c "import moviepy.editor; print('moviepy is installed')"

      - name: Create necessary directories
        run: |
          mkdir -p Storage/temp_tweets \
                   Storage/temp_captions \
                   Storage/temp_audio \
                   Storage/music_library \
                   Storage/temp_images \
                   Video/final_videos

      - name: Set up credentials
        shell: bash
        run: |
          # Create a file containing your Dropbox token
          echo "${{ secrets.DROPBOX_ACCESS_TOKEN }}" > ~/.dropbox_token

      - name: Run Gemini/Ficción.ipynb
        run: papermill Gemini/Ficción.ipynb Gemini/Ficción_output.ipynb -k github-actions

      - name: Run Gemini/tweets.ipynb
        run: papermill Gemini/tweets.ipynb Gemini/tweets_output.ipynb -k github-actions

      - name: Run Gemini/captions.ipynb
        run: papermill Gemini/captions.ipynb Gemini/captions_output.ipynb -k github-actions

      - name: Run Creators/audio_tts.ipynb
        run: papermill Creators/audio_tts.ipynb Creators/audio_tts_output.ipynb -k github-actions

      - name: Run Creators/music_downloader.ipynb
        run: papermill Creators/music_downloader.ipynb Creators/music_downloader_output.ipynb -k github-actions

      - name: Run Creators/text_animator.ipynb
        run: papermill Creators/text_animator.ipynb Creators/text_animator_output.ipynb -k github-actions

      - name: Run Video/video_assembler.ipynb
        run: papermill Video/video_assembler.ipynb Video/video_assembler_output.ipynb -k github-actions

      - name: Check if videos were generated
        id: check_videos
        run: |
          echo "Checking for videos in Video/final_videos directory:"
          ls -la Video/final_videos/
          
          # Count the number of video files
          VIDEO_COUNT=$(find Video/final_videos/ -type f -name "*.mp4" | wc -l)
          echo "VIDEO_COUNT=$VIDEO_COUNT" >> $GITHUB_ENV
          
          # If no videos were found, report the issue
          if [ "$VIDEO_COUNT" -eq 0 ]; then
            echo "No videos were found in Video/final_videos directory!"
            echo "videos_exist=false" >> $GITHUB_OUTPUT
          else
            echo "Found $VIDEO_COUNT videos in Video/final_videos directory."
            echo "videos_exist=true" >> $GITHUB_OUTPUT
          fi

      # Break uploads into smaller batches with delays between each batch
      
      - name: Upload tweet text files to Dropbox (Batch 1)
        uses: deka0106/upload-to-dropbox@v2
        with:
          dropbox_access_token: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
          src: Storage/temp_tweets
          dest: /text_files/tweets
          multiple: true
      
      - name: Wait between uploads
        run: sleep 15

      - name: Upload caption text files to Dropbox (Batch 2)
        uses: deka0106/upload-to-dropbox@v2
        with:
          dropbox_access_token: ${{ secrets.DROPBOX_ACCESS_TOKEN }}
          src: Storage/temp_captions
          dest: /text_files/captions
          multiple: true
      
      - name: Wait before video upload
        run: sleep 30

      # Custom approach for video upload with retry logic
      - name: Upload videos to Dropbox with retry logic
        if: ${{ steps.check_videos.outputs.videos_exist == 'true' }}
        run: |
          python -c "
          import os
          import time
          import dropbox
          from dropbox.exceptions import ApiError
          import glob
          
          # Initialize Dropbox client
          dbx = dropbox.Dropbox(os.environ['DROPBOX_TOKEN'])
          
          # Get all video files
          video_files = glob.glob('Video/final_videos/*.mp4')
          print(f'Found {len(video_files)} video files to upload')
          
          # Function to upload with retries
          def upload_with_retry(local_path, remote_path, max_retries=5, delay=30):
              attempt = 0
              while attempt < max_retries:
                  try:
                      print(f'Uploading {local_path} to Dropbox as {remote_path} (Attempt {attempt+1})')
                      with open(local_path, 'rb') as f:
                          dbx.files_upload(f.read(), remote_path, mode=dropbox.files.WriteMode.overwrite)
                      print(f'Successfully uploaded {local_path}')
                      return True
                  except ApiError as e:
                      if e.error.is_path() and e.error.get_path().is_insufficient_space():
                          print('Error: Insufficient space in Dropbox')
                          return False
                      elif hasattr(e.error, 'is_rate_limited') and e.error.is_rate_limited():
                          rate_limit_error = e.error.get_rate_limit_error()
                          retry_after = rate_limit_error.retry_after if hasattr(rate_limit_error, 'retry_after') else delay
                          print(f'Rate limit hit. Waiting for {retry_after} seconds before retry.')
                          time.sleep(retry_after)
                      else:
                          print(f'Error: {e}')
                          time.sleep(delay)
                  except Exception as e:
                      print(f'Unexpected error: {e}')
                  
                  attempt += 1
                  if attempt < max_retries:
                      print(f'Retrying... ({attempt+1}/{max_retries})')
                  else:
                      print(f'Max retries reached for {local_path}. Moving to next file.')
                  
                  # Add delay between attempts
                  time.sleep(delay)
              
              return False
          
          # Process files in batches with delays between files
          batch_size = 2
          for i in range(0, len(video_files), batch_size):
              batch = video_files[i:i+batch_size]
              print(f'Processing batch {i//batch_size + 1}')
              
              for local_file in batch:
                  # Extract filename
                  filename = os.path.basename(local_file)
                  # Create Dropbox path
                  dropbox_path = f'/videos/{filename}'
                  
                  # Upload with retry logic
                  success = upload_with_retry(local_file, dropbox_path)
                  if not success:
                      print(f'Failed to upload {local_file} after multiple attempts')
                  
                  # Add delay between files within a batch
                  time.sleep(10)
              
              # Add a longer delay between batches
              if i + batch_size < len(video_files):
                  print(f'Waiting between batches...')
                  time.sleep(30)
          
          print('Video upload process completed')
          " 
        env:
          DROPBOX_TOKEN: ${{ secrets.DROPBOX_ACCESS_TOKEN }}

      - name: Report upload status
        if: always()
        run: |
          echo "Tweet and caption file upload attempted"
          if [ "$VIDEO_COUNT" -eq 0 ]; then
            echo "No videos were found to upload. Check video_assembler.ipynb for issues."
          else
            echo "Attempted to upload $VIDEO_COUNT videos with retry logic"
          fi
